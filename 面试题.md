## 主流 Monorepo 技术方案对比

### 1. pnpm workspace

- **核心优势**：硬链接 + 符号链接，磁盘占用最小；严格的依赖隔离（避免幽灵依赖）
- **构建能力**：原生无任务编排，需配合 `pnpm -r --filter` 或外部工具
- **适用场景**：中小型项目，或作为其他工具的底层包管理器
- **命令示例**：`pnpm --filter @app/web... run build`（构建及其依赖）

### 2. Turborepo

- **核心优势**：增量构建 + 远程缓存（Vercel Remote Cache）；零配置上手快
- **技术实现**：基于任务哈希的缓存命中，Go 编写性能优异
- **局限**：功能相对单一，专注任务编排，无代码生成/依赖图可视化
- **典型配置**：

```json
{ "pipeline": { "build": { "dependsOn": ["^build"], "outputs": ["dist/**"] } } }
```

### 3. Nx

- **核心优势**：功能最全面——任务缓存、分布式执行、依赖图分析、代码生成器、插件生态
- **差异化**：`affected` 命令精准识别变更影响范围；支持 Module Federation
- **适用场景**：大型企业级项目，多团队协作
- **代价**：配置复杂度高，学习曲线陡峭

### 4. Rush（微软）

- **核心优势**：严格的版本策略管理、变更日志自动化、phantom dependency 检测
- **特色**：`rush change` 强制变更记录；支持 PNPM/NPM/Yarn 多种包管理器
- **适用场景**：大型企业，强合规要求，发布流程严格的团队

### 5. Lerna（Nx 维护）

- **现状**：已被 Nx 团队接管，推荐配合 Nx 使用
- **独立价值**：版本管理 + 发布（`lerna version` / `lerna publish`）
- **定位**：偏向 npm 包发布场景，任务编排能力弱于 Turborepo/Nx

---

## 组合方案推荐

| 场景              | 推荐方案                      |
| ----------------- | ----------------------------- |
| 轻量快速启动      | pnpm workspace + Turborepo    |
| 企业级全功能      | pnpm + Nx                     |
| npm 包发布        | pnpm + Changesets（或 Lerna） |
| 微软技术栈/强合规 | Rush                          |

---

## 核心能力对照

| 能力       | pnpm | Turbo |  Nx  | Rush |
| ---------- | :--: | :---: | :--: | :--: |
| 任务缓存   |  ❌  |  ✅   |  ✅  |  ✅  |
| 远程缓存   |  ❌  |  ✅   |  ✅  |  ✅  |
| 依赖图分析 |  ❌  | 基础  |  ✅  |  ✅  |
| 代码生成   |  ❌  |  ❌   |  ✅  |  ❌  |
| 分布式执行 |  ❌  |  ❌   |  ✅  |  ✅  |
| 发布管理   |  ❌  |  ❌   | 插件 |  ✅  |

**当前主流趋势**：pnpm 作为包管理器底座 + Turborepo/Nx 做任务编排已成事实标准。
